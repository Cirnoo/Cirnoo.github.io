---
layout: post
title:  "方便记忆的排序算法"
date:   2019-08-05 
categories: 算法
tags: C++
excerpt: 常见的排序算法的比较简洁的写法
---

* content
{:toc}

### 快排

```cpp
class Algorithm
{
public:
	static void qsort(vector<int> & vec, int l, int h)
	{
		if (l >= h)
			return;
		int mid = partition(vec, l, h);
		qsort(vec, l, mid - 1);
		qsort(vec, mid + 1, h);
	}

private:
	static int partition(vector<int> & arr, int l, int h)
	{
		int key = arr[l];
		while (l < h)
		{
			while (l < h && arr[h] >= key)
				--h;
			arr[l] = arr[h];
			while (l < h && arr[l] <= key)
				++l;
			arr[h] = arr[l];
		}
		arr[l] = key;
		return l;
	}
};
```

### 堆排序

```cpp
class Algorithm
{
public:
	static void HeapSort(vector<int> & arr, int n)
	{
		for (int i = n / 2 - 1; i >= 0; --i)
		{
			Adjust(arr, n, i);
		}
		for (int i = n - 1; i >= 1; --i)
		{
			swap(arr[0], arr[i]);
			Adjust(arr, i, 0);
		}
	}
private:
	static void Adjust(vector<int> & arr, int length, int index)
	{
		int left = 2 * index + 1;
		int right = left + 1;
		int max = index;
		if (left<length && arr[left]>arr[max])
			max = left;
		if (right<length && arr[right]>arr[max])
			max = right;
		if (max != index)
		{
			swap(arr[max], arr[index]);
			Adjust(arr, length, max);
		}
	}
};

```

### LRU

```cpp
class LRUCache
{
private:
	int cap;
	// 双链表：装着 (key, value) 元组
	list<pair<int, int>> cache;
	// 哈希表：key 映射到 (key, value) 在 cache 中的位置
	unordered_map<int, list<pair<int, int>>::iterator> map;
public:
	LRUCache(int capacity) 
	{
		this->cap = capacity;
	}

	int get(int key) 
	{
		auto it = map.find(key);
		// 访问的 key 不存在
		if (it == map.end()) return -1;
		// key 存在，把 (k, v) 换到队头
		pair<int, int> kv = *map[key];
		cache.erase(map[key]);
		cache.push_front(kv);
		// 更新 (key, value) 在 cache 中的位置
		map[key] = cache.begin();
		return kv.second; // value
	}

	void put(int key, int value)
	{

		/* 要先判断 key 是否已经存在 */
		auto it = map.find(key);
		if (it == map.end()) 
		{
			/* key 不存在，判断 cache 是否已满 */
			if (cache.size() == cap)
			{
				// cache 已满，删除尾部的键值对腾位置
				// cache 和 map 中的数据都要删除
				auto lastPair = cache.back();
				int lastKey = lastPair.first;
				map.erase(lastKey);
				cache.pop_back();
			}
			// cache 没满，可以直接添加
			cache.push_front(make_pair(key, value));
			map[key] = cache.begin();
		}
		else {
			/* key 存在，更改 value 并换到队头 */
			cache.erase(map[key]);
			cache.push_front(make_pair(key, value));
			map[key] = cache.begin();
		}
	}
};
```
